"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/thumbhash";
exports.ids = ["vendor-chunks/thumbhash"];
exports.modules = {

/***/ "(rsc)/./node_modules/thumbhash/thumbhash.js":
/*!*********************************************!*\
  !*** ./node_modules/thumbhash/thumbhash.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rgbaToDataURL: () => (/* binding */ rgbaToDataURL),\n/* harmony export */   rgbaToThumbHash: () => (/* binding */ rgbaToThumbHash),\n/* harmony export */   thumbHashToApproximateAspectRatio: () => (/* binding */ thumbHashToApproximateAspectRatio),\n/* harmony export */   thumbHashToAverageRGBA: () => (/* binding */ thumbHashToAverageRGBA),\n/* harmony export */   thumbHashToDataURL: () => (/* binding */ thumbHashToDataURL),\n/* harmony export */   thumbHashToRGBA: () => (/* binding */ thumbHashToRGBA)\n/* harmony export */ });\n/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nfunction rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)\n  let { PI, round, max, cos, abs } = Math\n\n  // Determine the average color\n  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    avg_r += alpha / 255 * rgba[j]\n    avg_g += alpha / 255 * rgba[j + 1]\n    avg_b += alpha / 255 * rgba[j + 2]\n    avg_a += alpha\n  }\n  if (avg_a) {\n    avg_r /= avg_a\n    avg_g /= avg_a\n    avg_b /= avg_a\n  }\n\n  let hasAlpha = avg_a < w * h\n  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)))\n  let ly = max(1, round(l_limit * h / max(w, h)))\n  let l = [] // luminance\n  let p = [] // yellow - blue\n  let q = [] // red - green\n  let a = [] // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]\n    l[i] = (r + g + b) / 3\n    p[i] = (r + g) / 2 - b\n    q[i] = r - g\n    a[i] = alpha\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0, ac = [], scale = 0, fx = []\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0\n        for (let x = 0; x < w; x++)\n          fx[x] = cos(PI / w * cx * (x + 0.5))\n        for (let y = 0; y < h; y++)\n          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)\n            f += channel[x + y * w] * fx[x] * fy\n        f /= w * h\n        if (cx || cy) {\n          ac.push(f)\n          scale = max(scale, abs(f))\n        } else {\n          dc = f\n        }\n      }\n    }\n    if (scale)\n      for (let i = 0; i < ac.length; i++)\n        ac[i] = 0.5 + 0.5 / scale * ac[i]\n    return [dc, ac, scale]\n  }\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []\n\n  // Write the constants\n  let isLandscape = w > h\n  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)\n  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)\n  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])\n    for (let f of ac)\n      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)\n  return new Uint8Array(hash)\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nfunction thumbHashToRGBA(hash) {\n  let { PI, min, max, cos, round } = Math\n\n  // Read the constants\n  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let header16 = hash[3] | (hash[4] << 8)\n  let l_dc = (header24 & 63) / 63\n  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1\n  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1\n  let l_scale = ((header24 >> 18) & 31) / 31\n  let hasAlpha = header24 >> 23\n  let p_scale = ((header16 >> 3) & 63) / 63\n  let q_scale = ((header16 >> 9) & 63) / 63\n  let isLandscape = header16 >> 15\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let a_scale = (hash[5] >> 4) / 15\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = []\n    for (let cy = 0; cy < ny; cy++)\n      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)\n        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)\n    return ac\n  }\n  let l_ac = decodeChannel(lx, ly, l_scale)\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25)\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25)\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash)\n  let w = round(ratio > 1 ? 32 : 32 * ratio)\n  let h = round(ratio > 1 ? 32 / ratio : 32)\n  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc, p = p_dc, q = q_dc, a = a_dc\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)\n        fx[cx] = cos(PI / w * (x + 0.5) * cx)\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)\n        fy[cy] = cos(PI / h * (y + 0.5) * cy)\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++)\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)\n          l += l_ac[j] * fx[cx] * fy2\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2\n          p += p_ac[j] * f\n          q += q_ac[j] * f\n        }\n      }\n\n      // Decode A\n      if (hasAlpha)\n        for (let cy = 0, j = 0; cy < 5; cy++)\n          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)\n            a += a_ac[j] * fx[cx] * fy2\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p\n      let r = (3 * l - b + q) / 2\n      let g = r - q\n      rgba[i] = max(0, 255 * min(1, r))\n      rgba[i + 1] = max(0, 255 * min(1, g))\n      rgba[i + 2] = max(0, 255 * min(1, b))\n      rgba[i + 3] = max(0, 255 * min(1, a))\n    }\n  }\n  return { w, h, rgba }\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nfunction thumbHashToAverageRGBA(hash) {\n  let { min, max } = Math\n  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let l = (header & 63) / 63\n  let p = ((header >> 6) & 63) / 31.5 - 1\n  let q = ((header >> 12) & 63) / 31.5 - 1\n  let hasAlpha = header >> 23\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let b = l - 2 / 3 * p\n  let r = (3 * l - b + q) / 2\n  let g = r - q\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  }\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nfunction thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3]\n  let hasAlpha = hash[2] & 0x80\n  let isLandscape = hash[4] & 0x80\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7\n  return lx / ly\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nfunction rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1\n  let idat = 6 + h * (5 + row)\n  let bytes = [\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,\n    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,\n    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,\n    73, 68, 65, 84, 120, 1\n  ]\n  let table = [\n    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,\n    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,\n    -2032938284, -1609899400, -1111625188\n  ]\n  let a = 1, b = 0\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255\n      bytes.push(u)\n      a = (a + u) % 65521\n      b = (b + a) % 65521\n    }\n  }\n  bytes.push(\n    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,\n    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n  )\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i]\n      c = (c >>> 4) ^ table[c & 15]\n      c = (c >>> 4) ^ table[c & 15]\n    }\n    c = ~c\n    bytes[end++] = c >>> 24\n    bytes[end++] = (c >> 16) & 255\n    bytes[end++] = (c >> 8) & 255\n    bytes[end++] = c & 255\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nfunction thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash)\n  return rgbaToDataURL(image.w, image.h, image.rgba)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGh1bWJoYXNoL3RodW1iaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZDQUE2QyxFQUFFLEdBQUcsR0FBRztBQUNyRCxRQUFRLDJCQUEyQjs7QUFFbkM7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qix1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsMkJBQTJCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDs7QUFFQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLG9EQUFvRCwwQkFBMEI7QUFDOUU7O0FBRUE7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxzREFBc0QsYUFBYTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3RpdmUtb3JiLWNvcHkvLi9ub2RlX21vZHVsZXMvdGh1bWJoYXNoL3RodW1iaGFzaC5qcz9mYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW5jb2RlcyBhbiBSR0JBIGltYWdlIHRvIGEgVGh1bWJIYXNoLiBSR0Igc2hvdWxkIG5vdCBiZSBwcmVtdWx0aXBsaWVkIGJ5IEEuXG4gKlxuICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCBpbWFnZS4gTXVzdCBiZSDiiaQxMDBweC5cbiAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IGltYWdlLiBNdXN0IGJlIOKJpDEwMHB4LlxuICogQHBhcmFtIHJnYmEgVGhlIHBpeGVscyBpbiB0aGUgaW5wdXQgaW1hZ2UsIHJvdy1ieS1yb3cuIE11c3QgaGF2ZSB3KmgqNCBlbGVtZW50cy5cbiAqIEByZXR1cm5zIFRoZSBUaHVtYkhhc2ggYXMgYSBVaW50OEFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiYVRvVGh1bWJIYXNoKHcsIGgsIHJnYmEpIHtcbiAgLy8gRW5jb2RpbmcgYW4gaW1hZ2UgbGFyZ2VyIHRoYW4gMTAweDEwMCBpcyBzbG93IHdpdGggbm8gYmVuZWZpdFxuICBpZiAodyA+IDEwMCB8fCBoID4gMTAwKSB0aHJvdyBuZXcgRXJyb3IoYCR7d314JHtofSBkb2Vzbid0IGZpdCBpbiAxMDB4MTAwYClcbiAgbGV0IHsgUEksIHJvdW5kLCBtYXgsIGNvcywgYWJzIH0gPSBNYXRoXG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBhdmVyYWdlIGNvbG9yXG4gIGxldCBhdmdfciA9IDAsIGF2Z19nID0gMCwgYXZnX2IgPSAwLCBhdmdfYSA9IDBcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdyAqIGg7IGkrKywgaiArPSA0KSB7XG4gICAgbGV0IGFscGhhID0gcmdiYVtqICsgM10gLyAyNTVcbiAgICBhdmdfciArPSBhbHBoYSAvIDI1NSAqIHJnYmFbal1cbiAgICBhdmdfZyArPSBhbHBoYSAvIDI1NSAqIHJnYmFbaiArIDFdXG4gICAgYXZnX2IgKz0gYWxwaGEgLyAyNTUgKiByZ2JhW2ogKyAyXVxuICAgIGF2Z19hICs9IGFscGhhXG4gIH1cbiAgaWYgKGF2Z19hKSB7XG4gICAgYXZnX3IgLz0gYXZnX2FcbiAgICBhdmdfZyAvPSBhdmdfYVxuICAgIGF2Z19iIC89IGF2Z19hXG4gIH1cblxuICBsZXQgaGFzQWxwaGEgPSBhdmdfYSA8IHcgKiBoXG4gIGxldCBsX2xpbWl0ID0gaGFzQWxwaGEgPyA1IDogNyAvLyBVc2UgZmV3ZXIgbHVtaW5hbmNlIGJpdHMgaWYgdGhlcmUncyBhbHBoYVxuICBsZXQgbHggPSBtYXgoMSwgcm91bmQobF9saW1pdCAqIHcgLyBtYXgodywgaCkpKVxuICBsZXQgbHkgPSBtYXgoMSwgcm91bmQobF9saW1pdCAqIGggLyBtYXgodywgaCkpKVxuICBsZXQgbCA9IFtdIC8vIGx1bWluYW5jZVxuICBsZXQgcCA9IFtdIC8vIHllbGxvdyAtIGJsdWVcbiAgbGV0IHEgPSBbXSAvLyByZWQgLSBncmVlblxuICBsZXQgYSA9IFtdIC8vIGFscGhhXG5cbiAgLy8gQ29udmVydCB0aGUgaW1hZ2UgZnJvbSBSR0JBIHRvIExQUUEgKGNvbXBvc2l0ZSBhdG9wIHRoZSBhdmVyYWdlIGNvbG9yKVxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB3ICogaDsgaSsrLCBqICs9IDQpIHtcbiAgICBsZXQgYWxwaGEgPSByZ2JhW2ogKyAzXSAvIDI1NVxuICAgIGxldCByID0gYXZnX3IgKiAoMSAtIGFscGhhKSArIGFscGhhIC8gMjU1ICogcmdiYVtqXVxuICAgIGxldCBnID0gYXZnX2cgKiAoMSAtIGFscGhhKSArIGFscGhhIC8gMjU1ICogcmdiYVtqICsgMV1cbiAgICBsZXQgYiA9IGF2Z19iICogKDEgLSBhbHBoYSkgKyBhbHBoYSAvIDI1NSAqIHJnYmFbaiArIDJdXG4gICAgbFtpXSA9IChyICsgZyArIGIpIC8gM1xuICAgIHBbaV0gPSAociArIGcpIC8gMiAtIGJcbiAgICBxW2ldID0gciAtIGdcbiAgICBhW2ldID0gYWxwaGFcbiAgfVxuXG4gIC8vIEVuY29kZSB1c2luZyB0aGUgRENUIGludG8gREMgKGNvbnN0YW50KSBhbmQgbm9ybWFsaXplZCBBQyAodmFyeWluZykgdGVybXNcbiAgbGV0IGVuY29kZUNoYW5uZWwgPSAoY2hhbm5lbCwgbngsIG55KSA9PiB7XG4gICAgbGV0IGRjID0gMCwgYWMgPSBbXSwgc2NhbGUgPSAwLCBmeCA9IFtdXG4gICAgZm9yIChsZXQgY3kgPSAwOyBjeSA8IG55OyBjeSsrKSB7XG4gICAgICBmb3IgKGxldCBjeCA9IDA7IGN4ICogbnkgPCBueCAqIChueSAtIGN5KTsgY3grKykge1xuICAgICAgICBsZXQgZiA9IDBcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3OyB4KyspXG4gICAgICAgICAgZnhbeF0gPSBjb3MoUEkgLyB3ICogY3ggKiAoeCArIDAuNSkpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKVxuICAgICAgICAgIGZvciAobGV0IHggPSAwLCBmeSA9IGNvcyhQSSAvIGggKiBjeSAqICh5ICsgMC41KSk7IHggPCB3OyB4KyspXG4gICAgICAgICAgICBmICs9IGNoYW5uZWxbeCArIHkgKiB3XSAqIGZ4W3hdICogZnlcbiAgICAgICAgZiAvPSB3ICogaFxuICAgICAgICBpZiAoY3ggfHwgY3kpIHtcbiAgICAgICAgICBhYy5wdXNoKGYpXG4gICAgICAgICAgc2NhbGUgPSBtYXgoc2NhbGUsIGFicyhmKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYyA9IGZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NhbGUpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjLmxlbmd0aDsgaSsrKVxuICAgICAgICBhY1tpXSA9IDAuNSArIDAuNSAvIHNjYWxlICogYWNbaV1cbiAgICByZXR1cm4gW2RjLCBhYywgc2NhbGVdXG4gIH1cbiAgbGV0IFtsX2RjLCBsX2FjLCBsX3NjYWxlXSA9IGVuY29kZUNoYW5uZWwobCwgbWF4KDMsIGx4KSwgbWF4KDMsIGx5KSlcbiAgbGV0IFtwX2RjLCBwX2FjLCBwX3NjYWxlXSA9IGVuY29kZUNoYW5uZWwocCwgMywgMylcbiAgbGV0IFtxX2RjLCBxX2FjLCBxX3NjYWxlXSA9IGVuY29kZUNoYW5uZWwocSwgMywgMylcbiAgbGV0IFthX2RjLCBhX2FjLCBhX3NjYWxlXSA9IGhhc0FscGhhID8gZW5jb2RlQ2hhbm5lbChhLCA1LCA1KSA6IFtdXG5cbiAgLy8gV3JpdGUgdGhlIGNvbnN0YW50c1xuICBsZXQgaXNMYW5kc2NhcGUgPSB3ID4gaFxuICBsZXQgaGVhZGVyMjQgPSByb3VuZCg2MyAqIGxfZGMpIHwgKHJvdW5kKDMxLjUgKyAzMS41ICogcF9kYykgPDwgNikgfCAocm91bmQoMzEuNSArIDMxLjUgKiBxX2RjKSA8PCAxMikgfCAocm91bmQoMzEgKiBsX3NjYWxlKSA8PCAxOCkgfCAoaGFzQWxwaGEgPDwgMjMpXG4gIGxldCBoZWFkZXIxNiA9IChpc0xhbmRzY2FwZSA/IGx5IDogbHgpIHwgKHJvdW5kKDYzICogcF9zY2FsZSkgPDwgMykgfCAocm91bmQoNjMgKiBxX3NjYWxlKSA8PCA5KSB8IChpc0xhbmRzY2FwZSA8PCAxNSlcbiAgbGV0IGhhc2ggPSBbaGVhZGVyMjQgJiAyNTUsIChoZWFkZXIyNCA+PiA4KSAmIDI1NSwgaGVhZGVyMjQgPj4gMTYsIGhlYWRlcjE2ICYgMjU1LCBoZWFkZXIxNiA+PiA4XVxuICBsZXQgYWNfc3RhcnQgPSBoYXNBbHBoYSA/IDYgOiA1XG4gIGxldCBhY19pbmRleCA9IDBcbiAgaWYgKGhhc0FscGhhKSBoYXNoLnB1c2gocm91bmQoMTUgKiBhX2RjKSB8IChyb3VuZCgxNSAqIGFfc2NhbGUpIDw8IDQpKVxuXG4gIC8vIFdyaXRlIHRoZSB2YXJ5aW5nIGZhY3RvcnNcbiAgZm9yIChsZXQgYWMgb2YgaGFzQWxwaGEgPyBbbF9hYywgcF9hYywgcV9hYywgYV9hY10gOiBbbF9hYywgcF9hYywgcV9hY10pXG4gICAgZm9yIChsZXQgZiBvZiBhYylcbiAgICAgIGhhc2hbYWNfc3RhcnQgKyAoYWNfaW5kZXggPj4gMSldIHw9IHJvdW5kKDE1ICogZikgPDwgKChhY19pbmRleCsrICYgMSkgPDwgMilcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhhc2gpXG59XG5cbi8qKlxuICogRGVjb2RlcyBhIFRodW1iSGFzaCB0byBhbiBSR0JBIGltYWdlLiBSR0IgaXMgbm90IGJlIHByZW11bHRpcGxpZWQgYnkgQS5cbiAqXG4gKiBAcGFyYW0gaGFzaCBUaGUgYnl0ZXMgb2YgdGhlIFRodW1iSGFzaC5cbiAqIEByZXR1cm5zIFRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgcGl4ZWxzIG9mIHRoZSByZW5kZXJlZCBwbGFjZWhvbGRlciBpbWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRodW1iSGFzaFRvUkdCQShoYXNoKSB7XG4gIGxldCB7IFBJLCBtaW4sIG1heCwgY29zLCByb3VuZCB9ID0gTWF0aFxuXG4gIC8vIFJlYWQgdGhlIGNvbnN0YW50c1xuICBsZXQgaGVhZGVyMjQgPSBoYXNoWzBdIHwgKGhhc2hbMV0gPDwgOCkgfCAoaGFzaFsyXSA8PCAxNilcbiAgbGV0IGhlYWRlcjE2ID0gaGFzaFszXSB8IChoYXNoWzRdIDw8IDgpXG4gIGxldCBsX2RjID0gKGhlYWRlcjI0ICYgNjMpIC8gNjNcbiAgbGV0IHBfZGMgPSAoKGhlYWRlcjI0ID4+IDYpICYgNjMpIC8gMzEuNSAtIDFcbiAgbGV0IHFfZGMgPSAoKGhlYWRlcjI0ID4+IDEyKSAmIDYzKSAvIDMxLjUgLSAxXG4gIGxldCBsX3NjYWxlID0gKChoZWFkZXIyNCA+PiAxOCkgJiAzMSkgLyAzMVxuICBsZXQgaGFzQWxwaGEgPSBoZWFkZXIyNCA+PiAyM1xuICBsZXQgcF9zY2FsZSA9ICgoaGVhZGVyMTYgPj4gMykgJiA2MykgLyA2M1xuICBsZXQgcV9zY2FsZSA9ICgoaGVhZGVyMTYgPj4gOSkgJiA2MykgLyA2M1xuICBsZXQgaXNMYW5kc2NhcGUgPSBoZWFkZXIxNiA+PiAxNVxuICBsZXQgbHggPSBtYXgoMywgaXNMYW5kc2NhcGUgPyBoYXNBbHBoYSA/IDUgOiA3IDogaGVhZGVyMTYgJiA3KVxuICBsZXQgbHkgPSBtYXgoMywgaXNMYW5kc2NhcGUgPyBoZWFkZXIxNiAmIDcgOiBoYXNBbHBoYSA/IDUgOiA3KVxuICBsZXQgYV9kYyA9IGhhc0FscGhhID8gKGhhc2hbNV0gJiAxNSkgLyAxNSA6IDFcbiAgbGV0IGFfc2NhbGUgPSAoaGFzaFs1XSA+PiA0KSAvIDE1XG5cbiAgLy8gUmVhZCB0aGUgdmFyeWluZyBmYWN0b3JzIChib29zdCBzYXR1cmF0aW9uIGJ5IDEuMjV4IHRvIGNvbXBlbnNhdGUgZm9yIHF1YW50aXphdGlvbilcbiAgbGV0IGFjX3N0YXJ0ID0gaGFzQWxwaGEgPyA2IDogNVxuICBsZXQgYWNfaW5kZXggPSAwXG4gIGxldCBkZWNvZGVDaGFubmVsID0gKG54LCBueSwgc2NhbGUpID0+IHtcbiAgICBsZXQgYWMgPSBbXVxuICAgIGZvciAobGV0IGN5ID0gMDsgY3kgPCBueTsgY3krKylcbiAgICAgIGZvciAobGV0IGN4ID0gY3kgPyAwIDogMTsgY3ggKiBueSA8IG54ICogKG55IC0gY3kpOyBjeCsrKVxuICAgICAgICBhYy5wdXNoKCgoKGhhc2hbYWNfc3RhcnQgKyAoYWNfaW5kZXggPj4gMSldID4+ICgoYWNfaW5kZXgrKyAmIDEpIDw8IDIpKSAmIDE1KSAvIDcuNSAtIDEpICogc2NhbGUpXG4gICAgcmV0dXJuIGFjXG4gIH1cbiAgbGV0IGxfYWMgPSBkZWNvZGVDaGFubmVsKGx4LCBseSwgbF9zY2FsZSlcbiAgbGV0IHBfYWMgPSBkZWNvZGVDaGFubmVsKDMsIDMsIHBfc2NhbGUgKiAxLjI1KVxuICBsZXQgcV9hYyA9IGRlY29kZUNoYW5uZWwoMywgMywgcV9zY2FsZSAqIDEuMjUpXG4gIGxldCBhX2FjID0gaGFzQWxwaGEgJiYgZGVjb2RlQ2hhbm5lbCg1LCA1LCBhX3NjYWxlKVxuXG4gIC8vIERlY29kZSB1c2luZyB0aGUgRENUIGludG8gUkdCXG4gIGxldCByYXRpbyA9IHRodW1iSGFzaFRvQXBwcm94aW1hdGVBc3BlY3RSYXRpbyhoYXNoKVxuICBsZXQgdyA9IHJvdW5kKHJhdGlvID4gMSA/IDMyIDogMzIgKiByYXRpbylcbiAgbGV0IGggPSByb3VuZChyYXRpbyA+IDEgPyAzMiAvIHJhdGlvIDogMzIpXG4gIGxldCByZ2JhID0gbmV3IFVpbnQ4QXJyYXkodyAqIGggKiA0KSwgZnggPSBbXSwgZnkgPSBbXVxuICBmb3IgKGxldCB5ID0gMCwgaSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHc7IHgrKywgaSArPSA0KSB7XG4gICAgICBsZXQgbCA9IGxfZGMsIHAgPSBwX2RjLCBxID0gcV9kYywgYSA9IGFfZGNcblxuICAgICAgLy8gUHJlY29tcHV0ZSB0aGUgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKGxldCBjeCA9IDAsIG4gPSBtYXgobHgsIGhhc0FscGhhID8gNSA6IDMpOyBjeCA8IG47IGN4KyspXG4gICAgICAgIGZ4W2N4XSA9IGNvcyhQSSAvIHcgKiAoeCArIDAuNSkgKiBjeClcbiAgICAgIGZvciAobGV0IGN5ID0gMCwgbiA9IG1heChseSwgaGFzQWxwaGEgPyA1IDogMyk7IGN5IDwgbjsgY3krKylcbiAgICAgICAgZnlbY3ldID0gY29zKFBJIC8gaCAqICh5ICsgMC41KSAqIGN5KVxuXG4gICAgICAvLyBEZWNvZGUgTFxuICAgICAgZm9yIChsZXQgY3kgPSAwLCBqID0gMDsgY3kgPCBseTsgY3krKylcbiAgICAgICAgZm9yIChsZXQgY3ggPSBjeSA/IDAgOiAxLCBmeTIgPSBmeVtjeV0gKiAyOyBjeCAqIGx5IDwgbHggKiAobHkgLSBjeSk7IGN4KyssIGorKylcbiAgICAgICAgICBsICs9IGxfYWNbal0gKiBmeFtjeF0gKiBmeTJcblxuICAgICAgLy8gRGVjb2RlIFAgYW5kIFFcbiAgICAgIGZvciAobGV0IGN5ID0gMCwgaiA9IDA7IGN5IDwgMzsgY3krKykge1xuICAgICAgICBmb3IgKGxldCBjeCA9IGN5ID8gMCA6IDEsIGZ5MiA9IGZ5W2N5XSAqIDI7IGN4IDwgMyAtIGN5OyBjeCsrLCBqKyspIHtcbiAgICAgICAgICBsZXQgZiA9IGZ4W2N4XSAqIGZ5MlxuICAgICAgICAgIHAgKz0gcF9hY1tqXSAqIGZcbiAgICAgICAgICBxICs9IHFfYWNbal0gKiBmXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGVjb2RlIEFcbiAgICAgIGlmIChoYXNBbHBoYSlcbiAgICAgICAgZm9yIChsZXQgY3kgPSAwLCBqID0gMDsgY3kgPCA1OyBjeSsrKVxuICAgICAgICAgIGZvciAobGV0IGN4ID0gY3kgPyAwIDogMSwgZnkyID0gZnlbY3ldICogMjsgY3ggPCA1IC0gY3k7IGN4KyssIGorKylcbiAgICAgICAgICAgIGEgKz0gYV9hY1tqXSAqIGZ4W2N4XSAqIGZ5MlxuXG4gICAgICAvLyBDb252ZXJ0IHRvIFJHQlxuICAgICAgbGV0IGIgPSBsIC0gMiAvIDMgKiBwXG4gICAgICBsZXQgciA9ICgzICogbCAtIGIgKyBxKSAvIDJcbiAgICAgIGxldCBnID0gciAtIHFcbiAgICAgIHJnYmFbaV0gPSBtYXgoMCwgMjU1ICogbWluKDEsIHIpKVxuICAgICAgcmdiYVtpICsgMV0gPSBtYXgoMCwgMjU1ICogbWluKDEsIGcpKVxuICAgICAgcmdiYVtpICsgMl0gPSBtYXgoMCwgMjU1ICogbWluKDEsIGIpKVxuICAgICAgcmdiYVtpICsgM10gPSBtYXgoMCwgMjU1ICogbWluKDEsIGEpKVxuICAgIH1cbiAgfVxuICByZXR1cm4geyB3LCBoLCByZ2JhIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYXZlcmFnZSBjb2xvciBmcm9tIGEgVGh1bWJIYXNoLiBSR0IgaXMgbm90IGJlIHByZW11bHRpcGxpZWQgYnkgQS5cbiAqXG4gKiBAcGFyYW0gaGFzaCBUaGUgYnl0ZXMgb2YgdGhlIFRodW1iSGFzaC5cbiAqIEByZXR1cm5zIFRoZSBSR0JBIHZhbHVlcyBmb3IgdGhlIGF2ZXJhZ2UgY29sb3IuIEVhY2ggdmFsdWUgcmFuZ2VzIGZyb20gMCB0byAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGh1bWJIYXNoVG9BdmVyYWdlUkdCQShoYXNoKSB7XG4gIGxldCB7IG1pbiwgbWF4IH0gPSBNYXRoXG4gIGxldCBoZWFkZXIgPSBoYXNoWzBdIHwgKGhhc2hbMV0gPDwgOCkgfCAoaGFzaFsyXSA8PCAxNilcbiAgbGV0IGwgPSAoaGVhZGVyICYgNjMpIC8gNjNcbiAgbGV0IHAgPSAoKGhlYWRlciA+PiA2KSAmIDYzKSAvIDMxLjUgLSAxXG4gIGxldCBxID0gKChoZWFkZXIgPj4gMTIpICYgNjMpIC8gMzEuNSAtIDFcbiAgbGV0IGhhc0FscGhhID0gaGVhZGVyID4+IDIzXG4gIGxldCBhID0gaGFzQWxwaGEgPyAoaGFzaFs1XSAmIDE1KSAvIDE1IDogMVxuICBsZXQgYiA9IGwgLSAyIC8gMyAqIHBcbiAgbGV0IHIgPSAoMyAqIGwgLSBiICsgcSkgLyAyXG4gIGxldCBnID0gciAtIHFcbiAgcmV0dXJuIHtcbiAgICByOiBtYXgoMCwgbWluKDEsIHIpKSxcbiAgICBnOiBtYXgoMCwgbWluKDEsIGcpKSxcbiAgICBiOiBtYXgoMCwgbWluKDEsIGIpKSxcbiAgICBhXG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYXBwcm94aW1hdGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAqXG4gKiBAcGFyYW0gaGFzaCBUaGUgYnl0ZXMgb2YgdGhlIFRodW1iSGFzaC5cbiAqIEByZXR1cm5zIFRoZSBhcHByb3hpbWF0ZSBhc3BlY3QgcmF0aW8gKGkuZS4gd2lkdGggLyBoZWlnaHQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGh1bWJIYXNoVG9BcHByb3hpbWF0ZUFzcGVjdFJhdGlvKGhhc2gpIHtcbiAgbGV0IGhlYWRlciA9IGhhc2hbM11cbiAgbGV0IGhhc0FscGhhID0gaGFzaFsyXSAmIDB4ODBcbiAgbGV0IGlzTGFuZHNjYXBlID0gaGFzaFs0XSAmIDB4ODBcbiAgbGV0IGx4ID0gaXNMYW5kc2NhcGUgPyBoYXNBbHBoYSA/IDUgOiA3IDogaGVhZGVyICYgN1xuICBsZXQgbHkgPSBpc0xhbmRzY2FwZSA/IGhlYWRlciAmIDcgOiBoYXNBbHBoYSA/IDUgOiA3XG4gIHJldHVybiBseCAvIGx5XG59XG5cbi8qKlxuICogRW5jb2RlcyBhbiBSR0JBIGltYWdlIHRvIGEgUE5HIGRhdGEgVVJMLiBSR0Igc2hvdWxkIG5vdCBiZSBwcmVtdWx0aXBsaWVkIGJ5XG4gKiBBLiBUaGlzIGlzIG9wdGltaXplZCBmb3Igc3BlZWQgYW5kIHNpbXBsaWNpdHkgYW5kIGRvZXMgbm90IG9wdGltaXplIGZvciBzaXplXG4gKiBhdCBhbGwuIFRoaXMgZG9lc24ndCBkbyBhbnkgY29tcHJlc3Npb24gKGFsbCB2YWx1ZXMgYXJlIHN0b3JlZCB1bmNvbXByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgaW1hZ2UuIE11c3QgYmUg4omkMTAwcHguXG4gKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCBpbWFnZS4gTXVzdCBiZSDiiaQxMDBweC5cbiAqIEBwYXJhbSByZ2JhIFRoZSBwaXhlbHMgaW4gdGhlIGlucHV0IGltYWdlLCByb3ctYnktcm93LiBNdXN0IGhhdmUgdypoKjQgZWxlbWVudHMuXG4gKiBAcmV0dXJucyBBIGRhdGEgVVJMIGNvbnRhaW5pbmcgYSBQTkcgZm9yIHRoZSBpbnB1dCBpbWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYmFUb0RhdGFVUkwodywgaCwgcmdiYSkge1xuICBsZXQgcm93ID0gdyAqIDQgKyAxXG4gIGxldCBpZGF0ID0gNiArIGggKiAoNSArIHJvdylcbiAgbGV0IGJ5dGVzID0gW1xuICAgIDEzNywgODAsIDc4LCA3MSwgMTMsIDEwLCAyNiwgMTAsIDAsIDAsIDAsIDEzLCA3MywgNzIsIDY4LCA4MiwgMCwgMCxcbiAgICB3ID4+IDgsIHcgJiAyNTUsIDAsIDAsIGggPj4gOCwgaCAmIDI1NSwgOCwgNiwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICBpZGF0ID4+PiAyNCwgKGlkYXQgPj4gMTYpICYgMjU1LCAoaWRhdCA+PiA4KSAmIDI1NSwgaWRhdCAmIDI1NSxcbiAgICA3MywgNjgsIDY1LCA4NCwgMTIwLCAxXG4gIF1cbiAgbGV0IHRhYmxlID0gW1xuICAgIDAsIDQ5ODUzNjU0OCwgOTk3MDczMDk2LCA2NTE3Njc5ODAsIDE5OTQxNDYxOTIsIDE4MDIxOTU0NDQsIDEzMDM1MzU5NjAsXG4gICAgMTM0MjUzMzk0OCwgLTMwNjY3NDkxMiwgLTI2NzQxNDcxNiwgLTY5MDU3NjQwOCwgLTg4Mjc4OTQ5MiwgLTE2ODc4OTUzNzYsXG4gICAgLTIwMzI5MzgyODQsIC0xNjA5ODk5NDAwLCAtMTExMTYyNTE4OFxuICBdXG4gIGxldCBhID0gMSwgYiA9IDBcbiAgZm9yIChsZXQgeSA9IDAsIGkgPSAwLCBlbmQgPSByb3cgLSAxOyB5IDwgaDsgeSsrLCBlbmQgKz0gcm93IC0gMSkge1xuICAgIGJ5dGVzLnB1c2goeSArIDEgPCBoID8gMCA6IDEsIHJvdyAmIDI1NSwgcm93ID4+IDgsIH5yb3cgJiAyNTUsIChyb3cgPj4gOCkgXiAyNTUsIDApXG4gICAgZm9yIChiID0gKGIgKyBhKSAlIDY1NTIxOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGxldCB1ID0gcmdiYVtpXSAmIDI1NVxuICAgICAgYnl0ZXMucHVzaCh1KVxuICAgICAgYSA9IChhICsgdSkgJSA2NTUyMVxuICAgICAgYiA9IChiICsgYSkgJSA2NTUyMVxuICAgIH1cbiAgfVxuICBieXRlcy5wdXNoKFxuICAgIGIgPj4gOCwgYiAmIDI1NSwgYSA+PiA4LCBhICYgMjU1LCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDczLCA2OSwgNzgsIDY4LCAxNzQsIDY2LCA5NiwgMTMwXG4gIClcbiAgZm9yIChsZXQgW3N0YXJ0LCBlbmRdIG9mIFtbMTIsIDI5XSwgWzM3LCA0MSArIGlkYXRdXSkge1xuICAgIGxldCBjID0gfjBcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgYyBePSBieXRlc1tpXVxuICAgICAgYyA9IChjID4+PiA0KSBeIHRhYmxlW2MgJiAxNV1cbiAgICAgIGMgPSAoYyA+Pj4gNCkgXiB0YWJsZVtjICYgMTVdXG4gICAgfVxuICAgIGMgPSB+Y1xuICAgIGJ5dGVzW2VuZCsrXSA9IGMgPj4+IDI0XG4gICAgYnl0ZXNbZW5kKytdID0gKGMgPj4gMTYpICYgMjU1XG4gICAgYnl0ZXNbZW5kKytdID0gKGMgPj4gOCkgJiAyNTVcbiAgICBieXRlc1tlbmQrK10gPSBjICYgMjU1XG4gIH1cbiAgcmV0dXJuICdkYXRhOmltYWdlL3BuZztiYXNlNjQsJyArIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcykpXG59XG5cbi8qKlxuICogRGVjb2RlcyBhIFRodW1iSGFzaCB0byBhIFBORyBkYXRhIFVSTC4gVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXRcbiAqIGp1c3QgY2FsbHMgXCJ0aHVtYkhhc2hUb1JHQkFcIiBmb2xsb3dlZCBieSBcInJnYmFUb0RhdGFVUkxcIi5cbiAqXG4gKiBAcGFyYW0gaGFzaCBUaGUgYnl0ZXMgb2YgdGhlIFRodW1iSGFzaC5cbiAqIEByZXR1cm5zIEEgZGF0YSBVUkwgY29udGFpbmluZyBhIFBORyBmb3IgdGhlIHJlbmRlcmVkIFRodW1iSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRodW1iSGFzaFRvRGF0YVVSTChoYXNoKSB7XG4gIGxldCBpbWFnZSA9IHRodW1iSGFzaFRvUkdCQShoYXNoKVxuICByZXR1cm4gcmdiYVRvRGF0YVVSTChpbWFnZS53LCBpbWFnZS5oLCBpbWFnZS5yZ2JhKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/thumbhash/thumbhash.js\n");

/***/ })

};
;